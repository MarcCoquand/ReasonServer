// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

function is(str) {
  return /* Exact */Block.__(0, [str]);
}

function text(f) {
  return /* Custom */Block.__(1, [f]);
}

function custom(f) {
  return /* Custom */Block.__(1, [f]);
}

function $neg$slash$neg(f, g) {
  return /* Slash */Block.__(2, [
            f,
            g
          ]);
}

function map(toMap, route) {
  return /* Map */Block.__(3, [
            toMap,
            route
          ]);
}

function oneOf(l) {
  return /* OneOf */Block.__(4, [l]);
}

function $eq$eq$great(route, handler) {
  return /* Map */Block.__(3, [
            handler,
            route
          ]);
}

function mapHelp(func, state) {
  return /* record */[
          /* url */state[/* url */0],
          /* offset */state[/* offset */1],
          /* length */state[/* length */2],
          /* value */Curry._1(func, state[/* value */3])
        ];
}

function concatMap(f, l) {
  return List.concat(List.map(f, l));
}

function isSubString(small, big, offset, _i, smallLen) {
  while(true) {
    var i = _i;
    if (i === smallLen) {
      return true;
    } else if (Caml_string.get(small, i) === Caml_string.get(big, offset + i | 0)) {
      _i = i + 1 | 0;
      continue ;
    } else {
      return false;
    }
  };
}

function chompExact(small, big, offset, length) {
  var smallLen = small.length;
  if (length < smallLen || smallLen === 0 || !isSubString(small, big, offset, 0, smallLen)) {
    return /* tuple */[
            -1,
            length
          ];
  } else {
    var newOffset = offset + smallLen | 0;
    var newLength = length - smallLen | 0;
    if (newLength === 0) {
      return /* tuple */[
              newOffset,
              newLength
            ];
    } else if (Caml_string.get(big, newOffset) === /* "/" */47) {
      return /* tuple */[
              newOffset + 1 | 0,
              newLength - 1 | 0
            ];
    } else {
      return /* tuple */[
              -1,
              length
            ];
    }
  }
}

function chompIntHelp(url, _offset, _length, _n) {
  while(true) {
    var n = _n;
    var length = _length;
    var offset = _offset;
    if (length === 0) {
      return /* tuple */[
              offset,
              length,
              n
            ];
    } else {
      var word = Caml_string.get(url, offset);
      if (word >= 48) {
        if (word >= 58) {
          return /* tuple */[
                  offset,
                  length,
                  n
                ];
        } else {
          _n = Caml_int32.imul(n, 10) + word | 0;
          _length = length - 1 | 0;
          _offset = offset + 1 | 0;
          continue ;
        }
      } else if (word >= 47) {
        return /* tuple */[
                offset + 1 | 0,
                length - 1 | 0,
                n
              ];
      } else {
        return /* tuple */[
                offset,
                length,
                n
              ];
      }
    }
  };
}

function chompInt(url, offset, length) {
  if (length === 0) {
    return /* tuple */[
            offset,
            length,
            0
          ];
  } else {
    var word = Caml_string.get(url, offset);
    if (word > 57 || word < 48) {
      return /* tuple */[
              offset,
              length,
              0
            ];
    } else {
      return chompIntHelp(url, offset + 1 | 0, length - 1 | 0, word);
    }
  }
}

function chompSegment(url, _offset, _length) {
  while(true) {
    var length = _length;
    var offset = _offset;
    if (length === 0) {
      return /* tuple */[
              offset,
              offset,
              length
            ];
    } else if (Caml_string.get(url, offset) === /* "/" */47) {
      return /* tuple */[
              offset,
              offset + 1 | 0,
              length - 1 | 0
            ];
    } else {
      _length = length - 1 | 0;
      _offset = offset + 1 | 0;
      continue ;
    }
  };
}

function attempt(route, state) {
  if (typeof route === "number") {
    if (route === 0) {
      if (state[/* length */2] === 0) {
        return /* :: */[
                state,
                /* [] */0
              ];
      } else {
        return /* [] */0;
      }
    } else {
      var match = chompInt(state[/* url */0], state[/* offset */1], state[/* length */2]);
      var newOffset = match[0];
      if (newOffset <= state[/* offset */1]) {
        return /* [] */0;
      } else {
        return /* :: */[
                /* record */[
                  /* url */state[/* url */0],
                  /* offset */newOffset,
                  /* length */match[1],
                  /* value */Curry._1(state[/* value */3], match[2])
                ],
                /* [] */0
              ];
      }
    }
  } else {
    switch (route.tag | 0) {
      case 0 : 
          var match$1 = chompExact(route[0], state[/* url */0], state[/* offset */1], state[/* length */2]);
          var newOffset$1 = match$1[0];
          if (newOffset$1 === -1) {
            return /* [] */0;
          } else {
            return /* :: */[
                    /* record */[
                      /* url */state[/* url */0],
                      /* offset */newOffset$1,
                      /* length */match$1[1],
                      /* value */state[/* value */3]
                    ],
                    /* [] */0
                  ];
          }
      case 1 : 
          var match$2 = chompSegment(state[/* url */0], state[/* offset */1], state[/* length */2]);
          var endOffset = match$2[0];
          if (endOffset === state[/* offset */1]) {
            return /* [] */0;
          } else {
            var subString = $$String.sub(state[/* url */0], state[/* offset */1], endOffset - state[/* offset */1] | 0);
            var match$3 = Curry._1(route[0], subString);
            if (match$3 !== undefined) {
              return /* :: */[
                      /* record */[
                        /* url */state[/* url */0],
                        /* offset */match$2[1],
                        /* length */match$2[2],
                        /* value */Curry._1(state[/* value */3], Caml_option.valFromOption(match$3))
                      ],
                      /* [] */0
                    ];
            } else {
              return /* [] */0;
            }
          }
      case 2 : 
          var after = route[1];
          var l = attempt(route[0], state);
          var f = function (param) {
            return attempt(after, param);
          };
          return List.concat(List.map(f, l));
      case 3 : 
          var partial_arg = state[/* value */3];
          return List.map((function (param) {
                        return mapHelp(partial_arg, param);
                      }), attempt(route[1], /* record */[
                          /* url */state[/* url */0],
                          /* offset */state[/* offset */1],
                          /* length */state[/* length */2],
                          /* value */route[0]
                        ]));
      case 4 : 
          return List.concat(List.map((function (p) {
                            return attempt(p, state);
                          }), route[0]));
      
    }
  }
}

function parseHelp(_states) {
  while(true) {
    var states = _states;
    if (states) {
      var state = states[0];
      if (state[/* length */2] === 0) {
        return Caml_option.some(state[/* value */3]);
      } else {
        _states = states[1];
        continue ;
      }
    } else {
      return undefined;
    }
  };
}

function parse(route, path) {
  var id = function (a) {
    return a;
  };
  return parseHelp(attempt(route, /* record */[
                  /* url */path,
                  /* offset */0,
                  /* length */path.length,
                  /* value */id
                ]));
}

function serve(path, router) {
  return parse(router, path);
}

var top = /* Top */0;

var $$int = /* Integer */1;

exports.top = top;
exports.is = is;
exports.$$int = $$int;
exports.text = text;
exports.custom = custom;
exports.$neg$slash$neg = $neg$slash$neg;
exports.map = map;
exports.oneOf = oneOf;
exports.$eq$eq$great = $eq$eq$great;
exports.mapHelp = mapHelp;
exports.concatMap = concatMap;
exports.isSubString = isSubString;
exports.chompExact = chompExact;
exports.chompIntHelp = chompIntHelp;
exports.chompInt = chompInt;
exports.chompSegment = chompSegment;
exports.attempt = attempt;
exports.parseHelp = parseHelp;
exports.parse = parse;
exports.serve = serve;
/* No side effect */
