// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");

function tap(str, value) {
  console.log(str + ": ", value);
  return value;
}

function mapHelp(func, state) {
  return /* record */[
          /* url */state[/* url */0],
          /* offset */state[/* offset */1],
          /* length */state[/* length */2],
          /* value */Curry._1(func, state[/* value */3]),
          /* queries */state[/* queries */4],
          /* method */state[/* method */5]
        ];
}

function concatMap(f, l) {
  return List.concat(List.map(f, l));
}

function extractValue(str, start, upto) {
  return $$String.sub(str, start, upto - start | 0);
}

function isSubString(small, big, offset, _i, smallLen) {
  while(true) {
    var i = _i;
    if (i === smallLen) {
      return true;
    } else if (Caml_string.get(small, i) === Caml_string.get(big, offset + i | 0)) {
      _i = i + 1 | 0;
      continue ;
    } else {
      return false;
    }
  };
}

function chompExact(small, big, offset, length) {
  var smallLen = small.length;
  if (length < smallLen || smallLen === 0 || !isSubString(small, big, offset, 0, smallLen)) {
    return /* tuple */[
            -1,
            length
          ];
  } else {
    var newOffset = offset + smallLen | 0;
    var newLength = length - smallLen | 0;
    if (newLength === 0) {
      return /* tuple */[
              newOffset,
              newLength
            ];
    } else if (Caml_string.get(big, newOffset) === /* "/" */47 || Caml_string.get(big, newOffset) === /* "&" */38 || Caml_string.get(big, newOffset) === /* "=" */61 || Caml_string.get(big, newOffset) === /* "?" */63) {
      return /* tuple */[
              newOffset + 1 | 0,
              newLength - 1 | 0
            ];
    } else {
      return /* tuple */[
              -1,
              length
            ];
    }
  }
}

function chompSegment(url, _offset, _length) {
  while(true) {
    var length = _length;
    var offset = _offset;
    if (length === 0) {
      return /* tuple */[
              offset,
              offset,
              length
            ];
    } else if (Caml_string.get(url, offset) === /* "/" */47 || Caml_string.get(url, offset) === /* "&" */38 || Caml_string.get(url, offset) === /* "=" */61 || Caml_string.get(url, offset) === /* "?" */63) {
      return /* tuple */[
              offset,
              offset + 1 | 0,
              length - 1 | 0
            ];
    } else {
      _length = length - 1 | 0;
      _offset = offset + 1 | 0;
      continue ;
    }
  };
}

function chompQueries(url, _offset, _length, _set) {
  while(true) {
    var set = _set;
    var length = _length;
    var offset = _offset;
    var match = chompSegment(url, offset, length);
    var offsetKey = match[1];
    if (offsetKey === offset) {
      return set;
    } else {
      var key = extractValue(url, offset, match[0]);
      var match$1 = chompSegment(url, offsetKey, match[2]);
      var nextOffset = match$1[1];
      if (nextOffset === offsetKey) {
        return set;
      } else {
        var queryValue = extractValue(url, offsetKey, match$1[0]);
        var newSet = Belt_MapString.set(set, key, queryValue);
        _set = newSet;
        _length = match$1[2];
        _offset = nextOffset;
        continue ;
      }
    }
  };
}

function charDigitToInt(str) {
  if (str > 57 || str < 48) {
    return undefined;
  } else {
    return str - 48 | 0;
  }
}

function chompIntHelp(url, _offset, _length, _n) {
  while(true) {
    var n = _n;
    var length = _length;
    var offset = _offset;
    if (length === 0) {
      return /* tuple */[
              offset,
              length,
              n
            ];
    } else {
      var word = Caml_string.get(url, offset);
      var match = charDigitToInt(word);
      if (match !== undefined) {
        _n = Caml_int32.imul(n, 10) + match | 0;
        _length = length - 1 | 0;
        _offset = offset + 1 | 0;
        continue ;
      } else {
        var match$1 = word === /* "/" */47 || word === /* "&" */38 || word === /* "=" */61 || word === /* "?" */63;
        if (match$1) {
          return /* tuple */[
                  offset + 1 | 0,
                  length - 1 | 0,
                  n
                ];
        } else {
          return /* tuple */[
                  offset,
                  length,
                  n
                ];
        }
      }
    }
  };
}

function chompInt(url, offset, length) {
  if (length === 0) {
    return /* tuple */[
            offset,
            length,
            0
          ];
  } else {
    var word = Caml_string.get(url, offset);
    var match = charDigitToInt(word);
    if (match !== undefined) {
      return chompIntHelp(url, offset + 1 | 0, length - 1 | 0, match);
    } else {
      return /* tuple */[
              offset,
              length,
              0
            ];
    }
  }
}

function attempt(route, state) {
  if (typeof route === "number") {
    if (route === 0) {
      if (state[/* length */2] === 0) {
        return /* :: */[
                state,
                /* [] */0
              ];
      } else {
        return /* [] */0;
      }
    } else {
      var match = chompInt(state[/* url */0], state[/* offset */1], state[/* length */2]);
      var newOffset = match[0];
      if (newOffset <= state[/* offset */1]) {
        return /* [] */0;
      } else {
        return /* :: */[
                /* record */[
                  /* url */state[/* url */0],
                  /* offset */newOffset,
                  /* length */match[1],
                  /* value */Curry._1(state[/* value */3], match[2]),
                  /* queries */state[/* queries */4],
                  /* method */state[/* method */5]
                ],
                /* [] */0
              ];
      }
    }
  } else {
    switch (route.tag | 0) {
      case 0 : 
          var match$1 = chompExact(route[0], state[/* url */0], state[/* offset */1], state[/* length */2]);
          var newOffset$1 = match$1[0];
          if (newOffset$1 === -1) {
            return /* [] */0;
          } else {
            return /* :: */[
                    /* record */[
                      /* url */state[/* url */0],
                      /* offset */newOffset$1,
                      /* length */match$1[1],
                      /* value */state[/* value */3],
                      /* queries */state[/* queries */4],
                      /* method */state[/* method */5]
                    ],
                    /* [] */0
                  ];
          }
      case 1 : 
          var match$2 = chompSegment(state[/* url */0], state[/* offset */1], state[/* length */2]);
          var endOffset = match$2[0];
          if (endOffset === state[/* offset */1]) {
            return /* [] */0;
          } else {
            var subString = $$String.sub(state[/* url */0], state[/* offset */1], endOffset - state[/* offset */1] | 0);
            var match$3 = Curry._1(route[0], subString);
            if (match$3 !== undefined) {
              return /* :: */[
                      /* record */[
                        /* url */state[/* url */0],
                        /* offset */match$2[1],
                        /* length */match$2[2],
                        /* value */Curry._1(state[/* value */3], Caml_option.valFromOption(match$3)),
                        /* queries */state[/* queries */4],
                        /* method */state[/* method */5]
                      ],
                      /* [] */0
                    ];
            } else {
              return /* [] */0;
            }
          }
      case 2 : 
          var after = route[1];
          var l = attempt(route[0], state);
          var f = function (param) {
            return attempt(after, param);
          };
          return List.concat(List.map(f, l));
      case 3 : 
          var partial_arg = state[/* value */3];
          return List.map((function (param) {
                        return mapHelp(partial_arg, param);
                      }), attempt(route[1], /* record */[
                          /* url */state[/* url */0],
                          /* offset */state[/* offset */1],
                          /* length */state[/* length */2],
                          /* value */route[0],
                          /* queries */state[/* queries */4],
                          /* method */state[/* method */5]
                        ]));
      case 4 : 
          return List.concat(List.map((function (p) {
                            return attempt(p, state);
                          }), route[0]));
      case 5 : 
          if (state[/* method */5] === route[0]) {
            return /* :: */[
                    state,
                    /* [] */0
                  ];
          } else {
            return /* [] */0;
          }
      case 6 : 
          var queries = Belt_Option.getWithDefault(state[/* queries */4], chompQueries(state[/* url */0], state[/* offset */1], state[/* length */2], Belt_MapString.empty));
          var match$4 = Belt_MapString.get(queries, route[0]);
          if (match$4 !== undefined) {
            return /* :: */[
                    /* record */[
                      /* url */"",
                      /* offset */state[/* offset */1],
                      /* length */0,
                      /* value */Curry._1(state[/* value */3], Curry._1(route[1], match$4)),
                      /* queries */Caml_option.some(queries),
                      /* method */state[/* method */5]
                    ],
                    /* [] */0
                  ];
          } else {
            return /* :: */[
                    /* record */[
                      /* url */"",
                      /* offset */state[/* offset */1],
                      /* length */0,
                      /* value */Curry._1(state[/* value */3], undefined),
                      /* queries */Caml_option.some(queries),
                      /* method */state[/* method */5]
                    ],
                    /* [] */0
                  ];
          }
      
    }
  }
}

function parseHelp(_states) {
  while(true) {
    var states = _states;
    if (states) {
      var state = states[0];
      if (state[/* length */2] === 0) {
        return Caml_option.some(state[/* value */3]);
      } else {
        _states = states[1];
        continue ;
      }
    } else {
      return undefined;
    }
  };
}

function parseUrl(route, method_, path) {
  var id = function (a) {
    return a;
  };
  var firstDropped = $$String.sub(path, 1, path.length - 1 | 0);
  return parseHelp(attempt(route, /* record */[
                  /* url */firstDropped,
                  /* offset */0,
                  /* length */firstDropped.length,
                  /* value */id,
                  /* queries */undefined,
                  /* method */method_
                ]));
}

function parseString(route, path) {
  var id = function (a) {
    return a;
  };
  return parseHelp(attempt(route, /* record */[
                  /* url */path,
                  /* offset */0,
                  /* length */path.length,
                  /* value */id,
                  /* queries */undefined,
                  /* method : GET */0
                ]));
}

function is(str) {
  return /* Exact */Block.__(0, [str]);
}

var text = /* Custom */Block.__(1, [(function (value) {
        return value;
      })]);

function custom(f) {
  return /* Custom */Block.__(1, [f]);
}

function $great$neg(f, g) {
  return /* Slash */Block.__(2, [
            f,
            g
          ]);
}

function map(toMap, route) {
  return /* Map */Block.__(3, [
            toMap,
            route
          ]);
}

function oneOf(l) {
  return /* OneOf */Block.__(4, [l]);
}

function $eq$eq$great(route, handler) {
  return /* Map */Block.__(3, [
            handler,
            route
          ]);
}

function query(str, f) {
  return /* Optional */Block.__(6, [
            str,
            (function (value) {
                return parseString(f, value);
              })
          ]);
}

function get(handler, route) {
  return /* Map */Block.__(3, [
            handler,
            /* Slash */Block.__(2, [
                /* Method */Block.__(5, [/* GET */0]),
                route
              ])
          ]);
}

var top = /* Top */0;

var $$int = /* Integer */1;

var post = /* Method */Block.__(5, [/* POST */1]);

var $$delete = /* Method */Block.__(5, [/* DELETE */4]);

var put = /* Method */Block.__(5, [/* PUT */2]);

var update = /* Method */Block.__(5, [/* UPDATE */3]);

var methodHead = /* Method */Block.__(5, [/* HEAD */5]);

var methodOption = /* Method */Block.__(5, [/* OPTION */6]);

var methodConnect = /* Method */Block.__(5, [/* CONNECT */7]);

var methodTrace = /* Method */Block.__(5, [/* TRACE */8]);

var patch = /* Method */Block.__(5, [/* PATCH */9]);

exports.tap = tap;
exports.mapHelp = mapHelp;
exports.concatMap = concatMap;
exports.extractValue = extractValue;
exports.isSubString = isSubString;
exports.chompExact = chompExact;
exports.chompSegment = chompSegment;
exports.chompQueries = chompQueries;
exports.charDigitToInt = charDigitToInt;
exports.chompIntHelp = chompIntHelp;
exports.chompInt = chompInt;
exports.attempt = attempt;
exports.parseHelp = parseHelp;
exports.parseUrl = parseUrl;
exports.parseString = parseString;
exports.top = top;
exports.is = is;
exports.$$int = $$int;
exports.text = text;
exports.custom = custom;
exports.$great$neg = $great$neg;
exports.map = map;
exports.oneOf = oneOf;
exports.$eq$eq$great = $eq$eq$great;
exports.query = query;
exports.get = get;
exports.post = post;
exports.$$delete = $$delete;
exports.put = put;
exports.update = update;
exports.methodHead = methodHead;
exports.methodOption = methodOption;
exports.methodConnect = methodConnect;
exports.methodTrace = methodTrace;
exports.patch = patch;
/* No side effect */
