// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Chomp$Cause = require("./Chomp.bs.js");
var Result$Cause = require("./Result.bs.js");
var Request$Cause = require("./Request.bs.js");

function first(param) {
  return param[0];
}

function second(param) {
  return param[1];
}

function id(x) {
  return x;
}

function concatMap(f, l) {
  return List.concat(List.map(f, l));
}

function mapHelp(f, state) {
  return /* tuple */[
          Curry._1(f, first(state)),
          second(state)
        ];
}

function attempt(route, state) {
  var st = state[1];
  var arg = state[0];
  if (typeof route === "number") {
    if (route === 0) {
      if (st[/* length */2] === 0) {
        return /* :: */[
                state,
                /* [] */0
              ];
      } else {
        return /* [] */0;
      }
    } else {
      var match = Chomp$Cause.$$int(st[/* url */0], st[/* offset */1], st[/* length */2]);
      var newOffset = match[0];
      if (newOffset <= st[/* offset */1]) {
        return /* [] */0;
      } else {
        return /* :: */[
                /* tuple */[
                  Curry._1(arg, match[2]),
                  /* record */[
                    /* url */st[/* url */0],
                    /* offset */newOffset,
                    /* length */match[1],
                    /* queries */st[/* queries */3],
                    /* contentType */st[/* contentType */4],
                    /* headers */st[/* headers */5],
                    /* accept */st[/* accept */6],
                    /* method */st[/* method */7],
                    /* rawBody */st[/* rawBody */8],
                    /* encoding */st[/* encoding */9]
                  ]
                ],
                /* [] */0
              ];
      }
    }
  } else {
    switch (route.tag | 0) {
      case 0 : 
          var match$1 = Chomp$Cause.exact(route[0], st[/* url */0], st[/* offset */1], st[/* length */2]);
          var newOffset$1 = match$1[0];
          if (newOffset$1 === -1) {
            return /* [] */0;
          } else {
            return /* :: */[
                    /* tuple */[
                      arg,
                      /* record */[
                        /* url */st[/* url */0],
                        /* offset */newOffset$1,
                        /* length */match$1[1],
                        /* queries */st[/* queries */3],
                        /* contentType */st[/* contentType */4],
                        /* headers */st[/* headers */5],
                        /* accept */st[/* accept */6],
                        /* method */st[/* method */7],
                        /* rawBody */st[/* rawBody */8],
                        /* encoding */st[/* encoding */9]
                      ]
                    ],
                    /* [] */0
                  ];
          }
      case 1 : 
          var match$2 = Chomp$Cause.segment(st[/* url */0], st[/* offset */1], st[/* length */2]);
          var endOffset = match$2[0];
          if (endOffset === st[/* offset */1]) {
            return /* [] */0;
          } else {
            var subString = $$String.sub(st[/* url */0], st[/* offset */1], endOffset - st[/* offset */1] | 0);
            var match$3 = Curry._1(route[0], subString);
            if (match$3 !== undefined) {
              return /* :: */[
                      /* tuple */[
                        Curry._1(arg, Caml_option.valFromOption(match$3)),
                        /* record */[
                          /* url */st[/* url */0],
                          /* offset */match$2[1],
                          /* length */match$2[2],
                          /* queries */st[/* queries */3],
                          /* contentType */st[/* contentType */4],
                          /* headers */st[/* headers */5],
                          /* accept */st[/* accept */6],
                          /* method */st[/* method */7],
                          /* rawBody */st[/* rawBody */8],
                          /* encoding */st[/* encoding */9]
                        ]
                      ],
                      /* [] */0
                    ];
            } else {
              return /* [] */0;
            }
          }
      case 2 : 
          var after = route[1];
          var l = attempt(route[0], state);
          var f = function (param) {
            return attempt(after, param);
          };
          return List.concat(List.map(f, l));
      case 3 : 
          return List.map((function (param) {
                        return mapHelp(arg, param);
                      }), attempt(route[1], /* tuple */[
                          route[0],
                          st
                        ]));
      case 4 : 
          return List.concat(List.map((function (p) {
                            return attempt(p, state);
                          }), route[0]));
      case 5 : 
          if (st[/* method */7] === route[0]) {
            return /* :: */[
                    state,
                    /* [] */0
                  ];
          } else {
            return /* [] */0;
          }
      
    }
  }
}

function is(str) {
  return /* Exact */Block.__(0, [str]);
}

var text = /* Custom */Block.__(1, [(function (value) {
        return value;
      })]);

function custom(f) {
  return /* Custom */Block.__(1, [f]);
}

function map(toMap, route) {
  return /* Map */Block.__(3, [
            toMap,
            route
          ]);
}

function oneOf(l) {
  return /* OneOf */Block.__(4, [l]);
}

function $neg$slash$neg(a, b) {
  return /* Slash */Block.__(2, [
            a,
            b
          ]);
}

function $eq$eq$great(a, b) {
  return /* Map */Block.__(3, [
            b,
            a
          ]);
}

var Method_000 = /* get : Method */Block.__(5, [/* GET */0]);

var Method_001 = /* post : Method */Block.__(5, [/* POST */1]);

var Method_002 = /* delete : Method */Block.__(5, [/* DELETE */4]);

var Method_003 = /* put : Method */Block.__(5, [/* PUT */2]);

var Method_004 = /* update : Method */Block.__(5, [/* UPDATE */3]);

var Method_005 = /* head : Method */Block.__(5, [/* HEAD */5]);

var Method_006 = /* option : Method */Block.__(5, [/* OPTION */6]);

var Method_007 = /* connect : Method */Block.__(5, [/* CONNECT */7]);

var Method_008 = /* trace : Method */Block.__(5, [/* TRACE */8]);

var Method_009 = /* patch : Method */Block.__(5, [/* PATCH */9]);

var Method = /* module */[
  Method_000,
  Method_001,
  Method_002,
  Method_003,
  Method_004,
  Method_005,
  Method_006,
  Method_007,
  Method_008,
  Method_009
];

function parseHelp(_results) {
  while(true) {
    var results = _results;
    if (results) {
      var match = results[0];
      var st = match[1];
      if (st[/* length */2] === 0) {
        return /* tuple */[
                match[0],
                st
              ];
      } else {
        _results = results[1];
        continue ;
      }
    } else {
      return undefined;
    }
  };
}

function parse(route, req) {
  var firstDropped = $$String.sub(req[/* url */0], 1, req[/* url */0].length - 1 | 0);
  return Result$Cause.attempt("Not found", /* NotFound404 */19, /* Plain */2, (function (param) {
                var r = param[1];
                return parseHelp(attempt(route, /* tuple */[
                                param[0],
                                /* record */[
                                  /* url */firstDropped,
                                  /* offset */r[/* offset */1],
                                  /* length */r[/* length */2] - 1 | 0,
                                  /* queries */r[/* queries */3],
                                  /* contentType */r[/* contentType */4],
                                  /* headers */r[/* headers */5],
                                  /* accept */r[/* accept */6],
                                  /* method */r[/* method */7],
                                  /* rawBody */r[/* rawBody */8],
                                  /* encoding */r[/* encoding */9]
                                ]
                              ]));
              }), /* tuple */[
              id,
              req
            ]);
}

function id$1(x) {
  return x;
}

function primitiveParse(router, uri) {
  var firstDropped = $$String.sub(uri, 1, uri.length - 1 | 0);
  var request = Request$Cause.mockGet(uri);
  var result = parseHelp(attempt(router, /* tuple */[
            id$1,
            /* record */[
              /* url */firstDropped,
              /* offset */request[/* offset */1],
              /* length */uri.length - 1 | 0,
              /* queries */request[/* queries */3],
              /* contentType */request[/* contentType */4],
              /* headers */request[/* headers */5],
              /* accept */request[/* accept */6],
              /* method */request[/* method */7],
              /* rawBody */request[/* rawBody */8],
              /* encoding */request[/* encoding */9]
            ]
          ]));
  return Belt_Option.map(result, first);
}

var top = /* Top */0;

var $$int = /* Integer */1;

exports.first = first;
exports.second = second;
exports.concatMap = concatMap;
exports.mapHelp = mapHelp;
exports.attempt = attempt;
exports.top = top;
exports.is = is;
exports.$$int = $$int;
exports.text = text;
exports.custom = custom;
exports.map = map;
exports.oneOf = oneOf;
exports.$neg$slash$neg = $neg$slash$neg;
exports.$eq$eq$great = $eq$eq$great;
exports.Method = Method;
exports.parseHelp = parseHelp;
exports.parse = parse;
exports.id = id$1;
exports.primitiveParse = primitiveParse;
/* Request-Cause Not a pure module */
