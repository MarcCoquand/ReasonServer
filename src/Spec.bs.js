// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Json = require("@glennsl/bs-json/src/Json.bs.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Belt_Int = require("bs-platform/lib/js/belt_Int.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");

function map(f, l) {
  if (l.tag) {
    return /* Failed */Block.__(1, [
              l[0],
              l[1]
            ]);
  } else {
    return /* Parsing */Block.__(0, [List.map(f, l[0])]);
  }
}

function concat(l) {
  if (l.tag) {
    return /* Failed */Block.__(1, [
              l[0],
              l[1]
            ]);
  } else {
    return List.fold_right((function (results, n) {
                  if (results.tag) {
                    return /* Failed */Block.__(1, [
                              results[0],
                              results[1]
                            ]);
                  } else if (n.tag) {
                    return /* Failed */Block.__(1, [
                              n[0],
                              n[1]
                            ]);
                  } else {
                    return /* Parsing */Block.__(0, [List.append(n[0], results[0])]);
                  }
                }), l[0], /* Parsing */Block.__(0, [/* [] */0]));
  }
}

function concatMap(f, l) {
  return concat(map(f, l));
}

var Progress = /* module */[
  /* map */map,
  /* concat */concat,
  /* concatMap */concatMap
];

function isSubString(small, big, offset, _i, smallLen) {
  while(true) {
    var i = _i;
    if (i === smallLen) {
      return true;
    } else if (Caml_string.get(small, i) === Caml_string.get(big, offset + i | 0)) {
      _i = i + 1 | 0;
      continue ;
    } else {
      return false;
    }
  };
}

function exact(small, big, offset, length) {
  var smallLen = small.length;
  if (length < smallLen || smallLen === 0 || !isSubString(small, big, offset, 0, smallLen)) {
    return /* tuple */[
            -1,
            length
          ];
  } else {
    var newOffset = offset + smallLen | 0;
    var newLength = length - smallLen | 0;
    if (newLength === 0) {
      return /* tuple */[
              newOffset,
              newLength
            ];
    } else if (Caml_string.get(big, newOffset) === /* "/" */47 || Caml_string.get(big, newOffset) === /* "&" */38 || Caml_string.get(big, newOffset) === /* "=" */61 || Caml_string.get(big, newOffset) === /* "?" */63) {
      return /* tuple */[
              newOffset + 1 | 0,
              newLength - 1 | 0
            ];
    } else {
      return /* tuple */[
              -1,
              length
            ];
    }
  }
}

function charDigitToInt(str) {
  if (str > 57 || str < 48) {
    return undefined;
  } else {
    return str - 48 | 0;
  }
}

function intHelp(url, _offset, _length, _n) {
  while(true) {
    var n = _n;
    var length = _length;
    var offset = _offset;
    if (length === 0) {
      return /* tuple */[
              offset,
              length,
              n
            ];
    } else {
      var word = Caml_string.get(url, offset);
      var match = charDigitToInt(word);
      if (match !== undefined) {
        _n = Caml_int32.imul(n, 10) + match | 0;
        _length = length - 1 | 0;
        _offset = offset + 1 | 0;
        continue ;
      } else {
        var match$1 = word === /* "/" */47 || word === /* "&" */38 || word === /* "=" */61 || word === /* "?" */63;
        if (match$1) {
          return /* tuple */[
                  offset + 1 | 0,
                  length - 1 | 0,
                  n
                ];
        } else {
          return /* tuple */[
                  offset,
                  length,
                  n
                ];
        }
      }
    }
  };
}

function $$int(url, offset, length) {
  if (length === 0) {
    return /* tuple */[
            offset,
            length,
            0
          ];
  } else {
    var word = Caml_string.get(url, offset);
    var match = charDigitToInt(word);
    if (match !== undefined) {
      return intHelp(url, offset + 1 | 0, length - 1 | 0, match);
    } else {
      return /* tuple */[
              offset,
              length,
              0
            ];
    }
  }
}

function segment(url, _offset, _length) {
  while(true) {
    var length = _length;
    var offset = _offset;
    if (length === 0) {
      return /* tuple */[
              offset,
              offset,
              length
            ];
    } else if (Caml_string.get(url, offset) === /* "/" */47 || Caml_string.get(url, offset) === /* "&" */38 || Caml_string.get(url, offset) === /* "=" */61 || Caml_string.get(url, offset) === /* "?" */63) {
      return /* tuple */[
              offset,
              offset + 1 | 0,
              length - 1 | 0
            ];
    } else {
      _length = length - 1 | 0;
      _offset = offset + 1 | 0;
      continue ;
    }
  };
}

function extractValue(str, start, upto) {
  return $$String.sub(str, start, upto - start | 0);
}

function queries(url, _offset, _length, _set) {
  while(true) {
    var set = _set;
    var length = _length;
    var offset = _offset;
    var match = segment(url, offset, length);
    var offsetKey = match[1];
    if (offsetKey === offset) {
      return set;
    } else {
      var key = extractValue(url, offset, match[0]);
      var match$1 = segment(url, offsetKey, match[2]);
      var nextOffset = match$1[1];
      if (nextOffset === offsetKey) {
        return set;
      } else {
        var queryValue = extractValue(url, offsetKey, match$1[0]);
        var newSet = Belt_MapString.set(set, key, queryValue);
        _set = newSet;
        _length = match$1[2];
        _offset = nextOffset;
        continue ;
      }
    }
  };
}

var Chomp = /* module */[
  /* isSubString */isSubString,
  /* exact */exact,
  /* charDigitToInt */charDigitToInt,
  /* intHelp */intHelp,
  /* int */$$int,
  /* segment */segment,
  /* extractValue */extractValue,
  /* queries */queries
];

function text(value) {
  return Caml_option.some(value);
}

var Query = /* module */[
  /* text */text,
  /* int */Belt_Int.fromString
];

function mapHelp(func, state) {
  return /* record */[
          /* url */state[/* url */0],
          /* offset */state[/* offset */1],
          /* length */state[/* length */2],
          /* value */Curry._1(func, state[/* value */3]),
          /* queries */state[/* queries */4],
          /* method */state[/* method */5],
          /* body */state[/* body */6]
        ];
}

function attempt(route, state) {
  if (typeof route === "number") {
    if (route === 0) {
      if (state[/* length */2] === 0) {
        return /* Parsing */Block.__(0, [/* :: */[
                    state,
                    /* [] */0
                  ]]);
      } else {
        return /* Parsing */Block.__(0, [/* [] */0]);
      }
    } else {
      var match = $$int(state[/* url */0], state[/* offset */1], state[/* length */2]);
      var newOffset = match[0];
      if (newOffset <= state[/* offset */1]) {
        return /* Parsing */Block.__(0, [/* [] */0]);
      } else {
        return /* Parsing */Block.__(0, [/* :: */[
                    /* record */[
                      /* url */state[/* url */0],
                      /* offset */newOffset,
                      /* length */match[1],
                      /* value */Curry._1(state[/* value */3], match[2]),
                      /* queries */state[/* queries */4],
                      /* method */state[/* method */5],
                      /* body */state[/* body */6]
                    ],
                    /* [] */0
                  ]]);
      }
    }
  } else {
    switch (route.tag | 0) {
      case 0 : 
          var match$1 = exact(route[0], state[/* url */0], state[/* offset */1], state[/* length */2]);
          var newOffset$1 = match$1[0];
          if (newOffset$1 === -1) {
            return /* Parsing */Block.__(0, [/* [] */0]);
          } else {
            return /* Parsing */Block.__(0, [/* :: */[
                        /* record */[
                          /* url */state[/* url */0],
                          /* offset */newOffset$1,
                          /* length */match$1[1],
                          /* value */state[/* value */3],
                          /* queries */state[/* queries */4],
                          /* method */state[/* method */5],
                          /* body */state[/* body */6]
                        ],
                        /* [] */0
                      ]]);
          }
      case 1 : 
          var match$2 = segment(state[/* url */0], state[/* offset */1], state[/* length */2]);
          var endOffset = match$2[0];
          if (endOffset === state[/* offset */1]) {
            return /* Parsing */Block.__(0, [/* [] */0]);
          } else {
            var subString = $$String.sub(state[/* url */0], state[/* offset */1], endOffset - state[/* offset */1] | 0);
            var match$3 = Curry._1(route[0], subString);
            if (match$3 !== undefined) {
              return /* Parsing */Block.__(0, [/* :: */[
                          /* record */[
                            /* url */state[/* url */0],
                            /* offset */match$2[1],
                            /* length */match$2[2],
                            /* value */Curry._1(state[/* value */3], Caml_option.valFromOption(match$3)),
                            /* queries */state[/* queries */4],
                            /* method */state[/* method */5],
                            /* body */state[/* body */6]
                          ],
                          /* [] */0
                        ]]);
            } else {
              return /* Parsing */Block.__(0, [/* [] */0]);
            }
          }
      case 2 : 
          var after = route[1];
          var l = attempt(route[0], state);
          var f = function (param) {
            return attempt(after, param);
          };
          return concat(map(f, l));
      case 3 : 
          var partial_arg = state[/* value */3];
          return map((function (param) {
                        return mapHelp(partial_arg, param);
                      }), attempt(route[1], /* record */[
                          /* url */state[/* url */0],
                          /* offset */state[/* offset */1],
                          /* length */state[/* length */2],
                          /* value */route[0],
                          /* queries */state[/* queries */4],
                          /* method */state[/* method */5],
                          /* body */state[/* body */6]
                        ]));
      case 4 : 
          return concat(map((function (p) {
                            return attempt(p, state);
                          }), /* Parsing */Block.__(0, [route[0]])));
      case 5 : 
          if (state[/* method */5] === route[0]) {
            return /* Parsing */Block.__(0, [/* :: */[
                        state,
                        /* [] */0
                      ]]);
          } else {
            return /* Parsing */Block.__(0, [/* [] */0]);
          }
      case 6 : 
          var match$4 = Curry._1(route[2], state[/* body */6]);
          if (match$4 !== undefined) {
            return /* Parsing */Block.__(0, [/* :: */[
                        /* record */[
                          /* url */state[/* url */0],
                          /* offset */state[/* offset */1],
                          /* length */state[/* length */2],
                          /* value */Curry._1(state[/* value */3], Caml_option.valFromOption(match$4)),
                          /* queries */state[/* queries */4],
                          /* method */state[/* method */5],
                          /* body */state[/* body */6]
                        ],
                        /* [] */0
                      ]]);
          } else {
            return /* Failed */Block.__(1, [
                      route[0],
                      route[1]
                    ]);
          }
      case 7 : 
          var queries$1 = Belt_Option.getWithDefault(state[/* queries */4], queries(state[/* url */0], state[/* offset */1], state[/* length */2], Belt_MapString.empty));
          var match$5 = Belt_MapString.get(queries$1, route[0]);
          if (match$5 !== undefined) {
            return /* Parsing */Block.__(0, [/* :: */[
                        /* record */[
                          /* url */"",
                          /* offset */state[/* offset */1],
                          /* length */0,
                          /* value */Curry._1(state[/* value */3], Curry._1(route[1], match$5)),
                          /* queries */Caml_option.some(queries$1),
                          /* method */state[/* method */5],
                          /* body */state[/* body */6]
                        ],
                        /* [] */0
                      ]]);
          } else {
            return /* Parsing */Block.__(0, [/* :: */[
                        /* record */[
                          /* url */"",
                          /* offset */state[/* offset */1],
                          /* length */0,
                          /* value */Curry._1(state[/* value */3], undefined),
                          /* queries */Caml_option.some(queries$1),
                          /* method */state[/* method */5],
                          /* body */state[/* body */6]
                        ],
                        /* [] */0
                      ]]);
          }
      
    }
  }
}

function parseHelp(_results) {
  while(true) {
    var results = _results;
    if (results.tag) {
      return /* Failed */Block.__(1, [
                results[0],
                results[1]
              ]);
    } else {
      var match = results[0];
      if (match) {
        var state = match[0];
        if (state[/* length */2] === 0) {
          return /* Success */Block.__(0, [state[/* value */3]]);
        } else {
          _results = /* Parsing */Block.__(0, [match[1]]);
          continue ;
        }
      } else {
        return /* Failed */Block.__(1, [
                  /* NotFound404 */19,
                  "Not found"
                ]);
      }
    }
  };
}

function parse(route, method_, path, body) {
  var id = function (a) {
    return a;
  };
  var firstDropped = $$String.sub(path, 1, path.length - 1 | 0);
  return parseHelp(attempt(route, /* record */[
                  /* url */firstDropped,
                  /* offset */0,
                  /* length */firstDropped.length,
                  /* value */id,
                  /* queries */undefined,
                  /* method */method_,
                  /* body */body
                ]));
}

function parseString(route, path) {
  var id = function (a) {
    return a;
  };
  return parseHelp(attempt(route, /* record */[
                  /* url */path,
                  /* offset */0,
                  /* length */path.length,
                  /* value */id,
                  /* queries */undefined,
                  /* method : GET */0,
                  /* body */""
                ]));
}

function is(str) {
  return /* Exact */Block.__(0, [str]);
}

var text$1 = /* Custom */Block.__(1, [(function (value) {
        return value;
      })]);

function custom(f) {
  return /* Custom */Block.__(1, [f]);
}

function map$1(toMap, route) {
  return /* Map */Block.__(3, [
            toMap,
            route
          ]);
}

function oneOf(l) {
  return /* OneOf */Block.__(4, [l]);
}

function jsonBody($staropt$star, $staropt$star$1, parser) {
  var failureCode = $staropt$star !== undefined ? $staropt$star : /* BadRequest400 */15;
  var failureMessage = $staropt$star$1 !== undefined ? $staropt$star$1 : "Invalid Json body";
  return /* Body */Block.__(6, [
            failureCode,
            failureMessage,
            (function (str) {
                return Belt_Option.map(Json.parse(str), parser);
              })
          ]);
}

var Required = /* module */[
  /* top : Top */0,
  /* is */is,
  /* int : Integer */1,
  /* text */text$1,
  /* custom */custom,
  /* map */map$1,
  /* oneOf */oneOf,
  /* jsonBody */jsonBody
];

function query(str, f) {
  return /* Optional */Block.__(7, [
            str,
            f
          ]);
}

function $eq$eq$great(route, handler) {
  return /* Map */Block.__(3, [
            handler,
            route
          ]);
}

function get(handler, route) {
  return /* Map */Block.__(3, [
            handler,
            /* Slash */Block.__(2, [
                /* Method */Block.__(5, [/* GET */0]),
                route
              ])
          ]);
}

function post(handler, route) {
  return /* Map */Block.__(3, [
            handler,
            /* Slash */Block.__(2, [
                /* Method */Block.__(5, [/* POST */1]),
                route
              ])
          ]);
}

function $$delete(handler, route) {
  return /* Map */Block.__(3, [
            handler,
            /* Slash */Block.__(2, [
                /* Method */Block.__(5, [/* DELETE */4]),
                route
              ])
          ]);
}

function put(handler, route) {
  return /* Map */Block.__(3, [
            handler,
            /* Slash */Block.__(2, [
                /* Method */Block.__(5, [/* PUT */2]),
                route
              ])
          ]);
}

function update(handler, route) {
  return /* Map */Block.__(3, [
            handler,
            /* Slash */Block.__(2, [
                /* Method */Block.__(5, [/* UPDATE */3]),
                route
              ])
          ]);
}

function methodHead(handler, route) {
  return /* Map */Block.__(3, [
            handler,
            /* Slash */Block.__(2, [
                /* Method */Block.__(5, [/* HEAD */5]),
                route
              ])
          ]);
}

function methodOption(handler, route) {
  return /* Map */Block.__(3, [
            handler,
            /* Slash */Block.__(2, [
                /* Method */Block.__(5, [/* OPTION */6]),
                route
              ])
          ]);
}

function methodConnect(handler, route) {
  return /* Map */Block.__(3, [
            handler,
            /* Slash */Block.__(2, [
                /* Method */Block.__(5, [/* CONNECT */7]),
                route
              ])
          ]);
}

function methodTrace(handler, route) {
  return /* Map */Block.__(3, [
            handler,
            /* Slash */Block.__(2, [
                /* Method */Block.__(5, [/* TRACE */8]),
                route
              ])
          ]);
}

function patch(handler, route) {
  return /* Map */Block.__(3, [
            handler,
            /* Slash */Block.__(2, [
                /* Method */Block.__(5, [/* PATCH */9]),
                route
              ])
          ]);
}

function $great$neg(f, g) {
  return /* Slash */Block.__(2, [
            f,
            g
          ]);
}

exports.Progress = Progress;
exports.Chomp = Chomp;
exports.Query = Query;
exports.mapHelp = mapHelp;
exports.attempt = attempt;
exports.parseHelp = parseHelp;
exports.parse = parse;
exports.parseString = parseString;
exports.Required = Required;
exports.query = query;
exports.$eq$eq$great = $eq$eq$great;
exports.get = get;
exports.post = post;
exports.$$delete = $$delete;
exports.put = put;
exports.update = update;
exports.methodHead = methodHead;
exports.methodOption = methodOption;
exports.methodConnect = methodConnect;
exports.methodTrace = methodTrace;
exports.patch = patch;
exports.$great$neg = $great$neg;
/* No side effect */
